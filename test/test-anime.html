<!doctype html>
<html>

<head>
    <meta charset="utf-8">
    <style type="text/css">
        html, body {
            height: 100%;
            width: 100%;
            margin: 0;
            overflow: hidden;
        }
        #area{
            position: absolute;
            left: 100px;
            top: 50px;
            height: 80%;
            width: 60%;
            border: 1px solid #000000;
        }
        .comment{
            color: #000000;
            border: 1px solid #FF6600;
        }
        .fix{
            float:left;
        }

        #play{
            width:50px;
        }        
    </style>
</head>

<body>
    <div id="timer">0</div>
    <button id="play", type=button data-func="play" onclick="play();">start</button>
    <input type="number" id="seek" /><button type=button onclick="seek();">seek</button>
    <div id="area"></div>
</body>

<script>
    // @ts-check
    var anime = require('animejs');
    var comment_elm = require("../comment");
    var nico_comment = require("../nico_comment");

    let getRnum = (min, max)=>{
        return Math.floor(Math.random() * (max-min+1) + min);
    };
    let getRstring = (min, max)=>{
        const s = "abcdefghijklmnopqrstuvwxyz0123456789()!?^あいうえおかきくけこさしすせそー";
        
        let cm = "";
        const cm_len = getRnum(min, max);
        for (let index = 0; index < cm_len; index++) {
            cm += s[getRnum(0, s.length-1)];
        }

        return cm;
    };
    let mk_cm = (cm_num, interval_ms)=>{
        let cms = [];
        cms.push({ no: 1, vpos: 0, text: getRstring(1, 30) });

        for (let index = 1; index < cm_num; index++) {
            const text = getRstring(1, 30);
            // const vpos = getRnum(0, time_ms/10);
            const interval = getRnum(200/10, interval_ms/10);
            const vpos = cms[cms.length-1].vpos + interval;
            cms.push({ no: index+1, vpos: vpos, text: text });
        }

        cms.sort((a, b) => {
            if (a.vpos < b.vpos) return -1;
            if (a.vpos > b.vpos) return 1;
            return 0;
        });

        return cms;
    };

    // let commnets = mk_cm(2000, 2*1000);
    // let commnets2 = mk_cm(1000, 2*1000);

    // let commnets = [
    //     { no: 1, vpos: 0, text: "AAAAA AAAAAAAAAA" },
    //     { no: 2, vpos: 250, text: "AAAAA" },
    //     { no: 3, vpos: 300, text: "AAAAAAAAAAAAAAA "},
    //     { no: 4, vpos: 450, text: "0" }
    // ];

    let commnets = [
        { no: 1, vpos: 0,    text: "あああああああああAAAああああ" },
        { no: 2, vpos: 143,  text: "いいいいいい" },
        { no: 3, vpos: 241,  text: "うううううううううううううう"},
        { no: 4, vpos: 274,  text: "ええええええええええ"},
        { no: 5, vpos: 362,  text: "おおおおおおおおおおおお" },
        { no: 6, vpos: 399,  text: "かかかかかかかかかかかかかかか" },
        { no: 7, vpos: 432,  text: "ききき" },
        { no: 8, vpos: 635,  text: "bbbbくくくくくくくくくくくくくくくく"},
        { no: 9, vpos: 712,  text: "けけけけけけ" },
        { no: 10, vpos: 743, text: "ここここここここここここここここここここここここここここここ" },
    ];

    let areabyid = document.getElementById("area");
    let elm = document.createElement("div");
    elm.innerHTML = "fix textsssss";
    elm.classList.add("comment", "fix");
    elm.style.opacity = 0;
    areabyid.appendChild(elm);
    elm.style.position = "absolute";
    elm.setAttribute("data-delay", (1000).toString());

    let elm2= document.createElement("div");
    elm2.innerHTML = "fix text2";
    elm2.classList.add("comment", "fix");
    elm2.style.opacity = 0;
    areabyid.appendChild(elm2);
    elm2.style.position = "absolute";
    elm2.style.top = 50 + "px";
    elm2.setAttribute("data-delay", (3000).toString());  

    class CommemtTimeLine{
        /**
         * @param {string} parent_selector
         * @param {{selector: string, duration: number}} flow_params
         * @param {{selector: string, duration: number}} fix_params
         */
        constructor(parent_selector, flow_params, fix_params) {
            this.parent_selector = parent_selector;
            this.flow_params = flow_params;
            this.fix_params = fix_params;
            this.flow_timeline = null;
            this.fix_timeline = null;
            this.is_play = false;
        }
        
        getMinDelay(selector){
            const elms = document.querySelectorAll(selector);
            this.mind = Math.min.apply(null, 
                Array.from(elms).map(elm => elm.getAttribute('data-delay')));
            console.log("mind=", this.mind);
        }

        createFlow(){
            const selector = this.flow_params.selector;
            const duration = this.flow_params.duration;

            if(this.flow_timeline != null){
                this.flow_timeline.pause();
                this.flow_timeline.reset();
                anime.remove(selector);
            }

            this.getMinDelay(selector);

            const area = document.querySelector(this.parent_selector);
            const area_width = area.clientWidth;
            let elms = document.querySelectorAll(selector);
            elms.forEach((elm)=>{
                elm.style.opacity = 0;
                elm.style.left = area_width + "px";
                const rowindex = parseInt(elm.getAttribute('data-rowindex'));
                elm.style.top = (rowindex * 30) + "px";
            });

            this.flow_timeline = anime.timeline({
                targets: selector,
                translateX: (el, i) => {
                    return -(area_width + el.getBoundingClientRect().width);
                },
                delay: (el, i) => {
                    return el.getAttribute('data-delay')-this.mind;
                },
                easing: 'linear',
                duration: duration,
                loop: false,
                autoplay: false
            });

            this.flow_timeline
            .add({
                translateX: 0,
                translateY: 0,
                opacity: 1,
                duration: 1
            })
            .add({
                translateY: 0,
                opacity: 1
            });
        }

        createFix(){
            const selector = this.fix_params.selector;
            const duration = this.fix_params.duration;

            if(this.fix_timeline != null){
                this.fix_timeline.pause();
                this.fix_timeline.reset();
                anime.remove(selector);
            }

            const area = document.querySelector(this.parent_selector);
            const area_width = area.clientWidth;
           
            let elms = document.querySelectorAll(selector);
            elms.forEach((elm)=>{
                elm.style.opacity = 0;
                const elm_rect = elm.getBoundingClientRect();
                elm.style.left = (area_width/2 - elm_rect.width/2) + "px";
            });

            this.fix_timeline = anime.timeline({
                targets: selector,
                delay: (el, i) => {
                    return el.getAttribute('data-delay');
                },
                // easing: 'linear',
                // duration: duration,
                loop: false,
                autoplay: false
            });

            this.fix_timeline
            .add({
                opacity: 1,
                duration: 1
            })
            .add({
                // opacity: 1,
                duration: duration
            })
            .add({
                opacity: 0,
                duration: 1,
            }); 
  
        }

        play(){
            if(!this._hasTimeline()) return;

            this.flow_timeline.play();
            this.is_play = true;
            //this.fix_timeline.play();
        }

        pause(){
            if(!this._hasTimeline()) return;

            this.flow_timeline.pause();
            this.is_play = false;
            //this.fix_timeline.pause();
        }

        seek(time_ms){
            if(!this._hasTimeline()) return;

            this.flow_timeline.seek(time_ms-this.mind);
            this.is_play = false;
            //this.fix_timeline.seek(time_ms);
        }

        _hasTimeline(){
            if(this.flow_timeline == null) return false;
            //if(this.fix_timeline == null) return false;
            
            return true;
        }
    };

    /**
     * 
     * @param {Array} commnets 
     */
    let make_tl = (commnets)=>{
        const parent_id = "area";
        let area = document.querySelector("#area");
        const width = area.clientWidth;
        const duration = 3000;
        const step = 4;

        let cm_elm = new comment_elm(parent_id, width, duration);
        let flow_params = [];
        let cnt=0;
        commnets.forEach((cm) => {
            const no = cm.no;
            const text = cm.text;
            const delay = cm.vpos*10;
            const q = Math.floor(cnt/step);
            cnt++;
            flow_params.push(cm_elm.createFlowElm(text, no, delay, `flow${q}`));
        });

        const num = 12;
        let cm = new nico_comment(num);
        cm.width = width;
        cm.comments = flow_params;
        cm.calc_comment();

        cm.comments.forEach((cm, index) => {
            cm.elm.setAttribute("data-rowindex", (cm.lane_index).toString());
        });  
        
        let clt_list = [];
        const q = Math.floor(commnets.length/step);
        const r = commnets.length%step;
        let nn = q;
        if(r>0){
            nn+=1;
        }
        for (let index = 0; index < nn; index++) {
            let ctl = new CommemtTimeLine("#area", 
            {selector: `.flow${index}`, duration: duration}, 
            {selector: ".fix", duration: duration});
            ctl.createFlow();
            //ctl.createFix();
            clt_list.push(ctl);
        }
     
        return clt_list;
    };   

    let ctl_list = make_tl(commnets);
    console.log("ctl_list.length=", ctl_list.length)

    let cutimer = 0;
    let cutimer_id;

    let getCurrentTime = ()=>{
        return cutimer;
    };
    const inv = 100;
    let int_timer=null;
    let test = ()=>{
        ctl_list.forEach((ctl) => {
            if(!ctl.is_play && ctl.mind<=getCurrentTime()){
                ctl.play();
            }
        });        
		if (int_timer) {
			int_timer = setTimeout( ()=> { 
                test(); 
            }, inv);
		}       
    };
    
    let play = ()=>{   
        let btn = document.querySelector('#play');
        if(btn.getAttribute('data-func')=="play"){
            if(int_timer==null){
                int_timer = setTimeout( ()=> { 
                    test(); 
                }, inv);
            }
            cutimer_id = setInterval(()=>{
                const target = document.getElementById("timer");
                target.textContent = cutimer;
                cutimer+=100;
            }, 100);;

            btn.textContent = "pause";
            btn.setAttribute('data-func', "pause");
        }else{
            clearInterval(cutimer_id);
            clearTimeout(int_timer);
            int_timer = null;
            ctl_list.forEach((ctl) => {
                ctl.pause();
            });

            btn.textContent = "play";
            btn.setAttribute('data-func', "play");
        }
    };

    let seek = ()=>{
        const target = document.getElementById("seek");
        const time_ms = parseInt(target.value);

        document.getElementById("timer").textContent = time_ms;

        ctl_list.forEach((ctl) => {
            ctl.seek(time_ms);
        });
    };

    let reset = ()=>{
        ctl_list.forEach((ctl) => {
            ctl.createFlow();
        });
    }

    let timer;
    const timeout = 200;
    window.addEventListener('resize', () => {
        clearTimeout(timer);
        timer = setTimeout(() => {
            reset();
        }, timeout);
    });
</script>

</html>